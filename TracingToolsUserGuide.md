

# Introduction #

`trace_inputs.py` traces any executable on supported OSes (Windows XP+, OSX 10.6+, anything with strace). It reports each child processes, their command line, initial current working directory, exit code, each file accessed per each child process in an hierarchical format. This is useful to get data about the amount of files read by each executable and get an idea of how many files are access by each of the processes, including child processes. It is good to know the amount of short-lived child processes that are created.

The output format is in json, so it can be easily consumed by a webpage, and is formatted in an OS-independent way as much as possible.

If you are looking to generate `.isolate` files, you are at the wrong place. The scripts below are used as libraries by the higher level scripts documents at IsolateUserGuide.


# Tracing an executable #

`trace_inputs.py` runs an executable, let it be notepad.exe or an unit test, under a tracer to log all the files that were opened or touched. It generates an OS-specific file that can be then read back to generate a JSON file.

In general, you will run it twice to generate a json file. First to trace it, second to read and analyze the traces generated by the tracer and output a json file.
```
python trace_inputs.py trace -l log_file path/to/foo_tests arg1 arg2 ...
python trace_inputs.py read -l log_file --root-dir . --json
```

## trace\_inputs.py ##

### clean ###

`clean` deletes all the logs properly.
```
python trace_inputs.py clean -l log_file
```

### help ###

`help` prints information about a specific subcommand.
```
python trace_inputs.py help trace
```

### read ###

`read` reads a trace previously generated with `trace`. The example below strips any file accessed outside of `--root-dir` to reduce noise and replaces any path with the corresponding variable with `--variable`. Variables are useful to abstract difference with the OS or the build tool, like abstracting the build output directory.
```
python trace_inputs.py read -l log_file -V PRODUCT_DIR out/Release --root-dir /home/$USER/chrome/src --json
```

### trace ###

`trace` executes an executable under the tracer and generates a new trace log. It doesn't output any information. Use `read` to read the trace.
```
python trace_inputs.py trace -l log_file out/Release/base_unittests
```


# Caveats #

OS-specific tracer limitations may limit the amount of information;
  * **dtrace** has issues tracing the command line on OSX
  * **Windows' NT Kernel tracer** doesn't trace the initial working directory, because there is no such concept at the kernel level; the current working directory is purely a user-mode implementation on Windows.
    * Windows implementation is by far the slowest of the supported platform.
  * **strace** may require a recent version to work properly (2.8+).

Access control;
  * **dtrace** requires root password on OSX. You can work around with `setuid` or `visudo` but there are security-related implications.
  * **logman.exe** requires elevated privileges on Windows. This means calling "`trace_inputs.py trace ...`" requires an elevated command prompt.